# Troubleshooting Log & Lessons Learned

This document tracks significant issues encountered during development and the lessons learned from resolving them.

## May 2025: Sprint 0 Verification Issues

### 1. Build Output Missing Scripts (`Cannot find module`)

*   **Symptom:** Running a script via `npm run` inside a Docker container failed with `Error: Cannot find module '/app/dist/...`.
*   **Diagnosis:** A TypeScript script (`.ts`) located outside the primary `src/` directory (e.g., in `temp-scripts/` or `scripts/` if not configured) was not being included in the compilation output (`dist/`) generated by `tsc` (invoked by `npm run build`).
*   **Resolution:**
    1.  Ensure the script's directory (e.g., `src/scripts`) is included in the `include` array within `tsconfig.json`. Example: `"include": ["src/**/*", "src/scripts/**/*"]`.
    2.  Update the corresponding `npm run` script in `package.json` to point to the correct path within the `dist/` directory (e.g., `node dist/scripts/myScript.js`).
    3.  Rebuild the Docker image (`docker-compose build --no-cache <service-name>`).

### 2. Environment Variables Unavailable in `docker-compose exec` (`ENV_VAR is not set`)

*   **Symptom:** A script run via `docker-compose exec <service-name> npm run <script-name>` failed because an environment variable (e.g., `REDIS_URL`) expected via `process.env.VAR_NAME` was undefined.
*   **Diagnosis:** Commands executed with `docker-compose exec` do not automatically inherit the full environment variable set defined in the `docker-compose.yml` file for the service, nor do they typically load `.env` files automatically within the container's context in the same way a service's main entrypoint might.
*   **Attempted Fix & Issue:** Using `dotenv-cli` (e.g., `"script": "dotenv -- node dist/script.js"`) in `package.json` failed with `sh: 1: dotenv: not found`. This occurred because `dotenv-cli` was installed as a `devDependency` and was removed from the final production image by `npm prune --omit=dev` during the Docker build process.
*   **Workaround (for temporary/test scripts):** Hardcode the required value directly into the script (e.g., `const redisUrl = 'redis://redis:6379';`). This avoids the complexity of environment loading for simple, non-production scripts but should **not** be used for sensitive credentials or production code.
*   **Proper Fix (Alternative):** Move necessary tools like `dotenv-cli` from `devDependencies` to `dependencies` in `package.json` if they are required for scripts run in the production container. Rebuild the image.
*   **Proper Fix (Alternative 2):** Pass the required environment variable directly using the `-e` flag with `docker-compose exec`: `docker-compose exec -e MY_VAR=$MY_VAR backend node dist/script.js`. This requires the variable to be available in the *host* shell running the command.
*   **Lesson:** Be mindful of the environment context when using `docker-compose exec`. Variables defined in `docker-compose.yml` are primarily for the main service process, not necessarily for one-off `exec` commands. Also, be aware of which dependencies are pruned from production Docker images.

## May 2025: E2E Testing Issues

### 1. Redis Connection Errors in E2E Tests

*   **Symptom:** E2E tests for the capture worker were failing with `ENOTFOUND` errors for hostname `redis` during test execution.
*   **Diagnosis:** The `captureWorker.ts` file was creating Redis/BullMQ connections at the top level of the module, causing connection attempts when the module was imported during tests. The tests were using the production `REDIS_URL` (redis://redis:6379) defined in `.env`.
*   **Resolution:**
    1.  Refactored `captureWorker.ts` to wrap connection/worker initialization logic in a `startWorker()` function
    2.  Added conditional execution using `if (require.main === module)` to prevent automatic connections during imports
    3.  Modified `processCaptureJob` to accept a `Queue` instance as a parameter to support dependency injection
    4.  Updated the E2E tests to provide a mock queue instance

### 2. Jest Timeout and Mock Issues in E2E Tests

*   **Symptom:** Tests were failing with timeout errors and mock expectation failures despite the logs showing the expected behavior.
*   **Diagnosis:** Multiple issues:
    1. Default Jest timeout (5000ms) was too short for the E2E test
    2. Asynchronous operations weren't being properly awaited before test completion
    3. Mock functions weren't being properly tracked across module boundaries
*   **Resolution:**
    1. Added `jest.setTimeout(30000)` at the test file level
    2. Added a delay after the worker execution to allow async operations to complete
    3. Improved the mock setup by exposing the mock functions and using proper type assertions
    4. Added more flexible assertions to handle race conditions with server shutdown
    5. Enhanced debug logging to understand mock call counts and function references
